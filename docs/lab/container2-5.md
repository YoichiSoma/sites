# まとめ
全体を通してCode系を利用したECSへのデプロの流れはこのような形になる

![pipeline](https://user-images.githubusercontent.com/125415634/232721562-19da026c-899d-4698-9ac3-58a127ad5737.png)

---

### それぞれの処理や動きの説明

例としてユーザがコンテナの内容を変えたとする。その場合以下の流れ処理が行われる

- CodePipelineがコード変更の検知 (①、②)
   - ユーザが[Dockerfile]ファイルを変更し、CodeCommitのXXXリポジトリのYYYYブランチにプッシュする。
   - CodePipelineのソースステージに設定した内容を元に、上記ブランチに更新が発生した場合パイプラインを開始する。
- ソースステージ処理 (③)
   - ビルド及びデプロイに必要なファイルをアーティファクトストアで設定したS3バケットに一時的にデータを格納する。
      - デフォルトでは自アカウントにて適当な名前でS3バケットが作成され、そちらのバケット内にデータが格納される
- ビルドステージ処理 (④)
   - [buildspec.yml]の内容を元にコンテナビルドを実行
   - 基本的な内容としては
      - [Dockerfile]の内容に沿ってベースイメージの取得から必要に応じてプログラムのダウンロードやファイル配置を行い、オリジナルのコンテナイメージを作成
      - 作成したイメージファイルを指定したECRリポジトリへアップロード
      - この際にデプロイステージで利用する[imageDetail.json]を生成し、S3バケットに格納する
- デプロイステージ処理 (⑤)
   - ECSクラスタで稼働するための処理を順々に実行
      - [taskdef.json]の内容を元タスク定義の更新
         - この際に[imageDetail.json]に記載されたImageURIの値が<IMAGE1_NAME>変数に代入され、タスク定義が更新される 
      - [appspec.yaml]の内容をもとに別のコンテナサービスを起動し、[blue/Greenデプロイ処理]でALBの参照ターゲットが切り替わる

ここまでのCI/CD処理を作成しておけば開発者としてはDockerFileを更新するだけで、ECSへ自動的に新しいコンテナが展開されることとなる。
